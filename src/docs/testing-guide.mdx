import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Introduction/Testing Guide" />

# Testing Guide

shadcn-storybook-registry의 테스트 전략과 작성 가이드입니다.

## Testing Strategy

이 프로젝트는 3가지 테스트 레이어로 구성됩니다:

- **Play Functions**: Storybook 내에서 인터랙션 테스트
- **Vitest Unit Tests**: 컴포넌트 로직 단위 테스트
- **Playwright Browser Tests**: 실제 브라우저 환경에서 E2E 테스트

## Play Functions

Storybook 9의 **Play Functions**는 컴포넌트 인터랙션을 자동으로 테스트합니다.

### Basic Structure

```typescript
import type { Meta, StoryObj } from "@storybook/nextjs-vite";
import { expect, userEvent, within, waitFor } from "storybook/test";
import { Button } from "@/components/ui/button";

const meta: Meta<typeof Button> = {
  title: "ui/Button",
  component: Button,
  tags: ["autodocs"],
};

export default meta;
type Story = StoryObj<typeof meta>;

/**
 * 버튼 클릭 시 상태가 변경되는지 테스트합니다.
 */
export const ShouldToggleOnClick: Story = {
  tags: ["!dev", "!autodocs"], // 👈 테스트 전용 스토리
  render: () => {
    const [clicked, setClicked] = React.useState(false);
    return (
      <Button onClick={() => setClicked(!clicked)}>
        {clicked ? "Clicked" : "Click me"}
      </Button>
    );
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // 🎯 목적: 버튼 클릭 시 텍스트가 변경되는지 확인
    const button = canvas.getByRole("button", { name: /click me/i });
    await expect(button).toBeInTheDocument();

    // 버튼 클릭
    await userEvent.click(button);

    // 텍스트 변경 확인
    await waitFor(() => {
      expect(button).toHaveTextContent("Clicked");
    });
  },
};
```

### Story Naming Convention

Play function 스토리는 **`Should...`** 패턴을 사용합니다:

- ✅ `ShouldOpenDialog`
- ✅ `ShouldSelectDate`
- ✅ `ShouldValidateForm`
- ❌ `TestDialog`
- ❌ `CheckValidation`

### Tags Configuration

```typescript
tags: ["!dev", "!autodocs"]
```

- `!dev`: Dev mode에서 숨김
- `!autodocs`: Autodocs 페이지에서 제외

### Common Patterns

#### 1. Button Interactions

```typescript
// 버튼 찾기
const button = canvas.getByRole("button", { name: /submit/i });

// 클릭
await userEvent.click(button);

// 상태 확인
await expect(button).toBeDisabled();
```

#### 2. Form Inputs

```typescript
// Input 찾기
const input = canvas.getByRole("textbox", { name: /email/i });

// 텍스트 입력
await userEvent.type(input, "test@example.com");

// 값 확인
await expect(input).toHaveValue("test@example.com");
```

#### 3. Dialog/Popover Opening

```typescript
// 트리거 클릭
await userEvent.click(canvas.getByRole("button", { name: /open/i }));

// Dialog 열림 확인
await waitFor(async () => {
  const dialog = await canvas.findByRole("dialog");
  await expect(dialog).toBeInTheDocument();
});
```

#### 4. Select/Combobox

```typescript
// Select 열기
await userEvent.click(canvas.getByRole("combobox"));

// 옵션 선택
const option = canvas.getByRole("option", { name: /option 1/i });
await userEvent.click(option);

// 선택 확인
await expect(canvas.getByRole("combobox")).toHaveTextContent("Option 1");
```

#### 5. Keyboard Navigation

```typescript
// Tab 키
await userEvent.tab();

// Enter 키
await userEvent.keyboard("{Enter}");

// Escape 키
await userEvent.keyboard("{Escape}");

// Arrow keys
await userEvent.keyboard("{ArrowDown}");
```

### 한국어 주석 필수

모든 Play function에는 `🎯 목적` 주석을 포함해야 합니다:

```typescript
play: async ({ canvasElement }) => {
  const canvas = within(canvasElement);

  // 🎯 목적: Form 제출 시 validation 에러가 표시되는지 확인
  const submitButton = canvas.getByRole("button", { name: /submit/i });
  await userEvent.click(submitButton);

  // Validation 에러 확인
  await waitFor(() => {
    expect(canvas.getByText(/required/i)).toBeInTheDocument();
  });
},
```

### Testing Async Operations

```typescript
// Loading 상태 테스트
await userEvent.click(submitButton);

// Loading spinner 표시 확인
await expect(canvas.getByRole("status")).toBeInTheDocument();

// 완료 후 성공 메시지 확인
await waitFor(
  () => {
    expect(canvas.getByText(/success/i)).toBeInTheDocument();
  },
  { timeout: 3000 }
);
```

## Vitest Unit Tests

**Vitest**로 컴포넌트 로직을 단위 테스트합니다.

### Running Tests

```bash
# 모든 테스트 실행
npm run test

# 유닛 테스트만 실행
npm run test:unit

# Watch mode
npm run test:unit -- --watch
```

### Test File Structure

```typescript
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import { Button } from "@/components/ui/button";

describe("Button", () => {
  it("should render with default variant", () => {
    render(<Button>Click me</Button>);
    const button = screen.getByRole("button");
    expect(button).toHaveClass("bg-primary");
  });

  it("should call onClick handler", () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);

    const button = screen.getByRole("button");
    button.click();

    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it("should be disabled when disabled prop is true", () => {
    render(<Button disabled>Click me</Button>);
    const button = screen.getByRole("button");
    expect(button).toBeDisabled();
  });
});
```

### Mocking

```typescript
// Mock 함수
const mockFn = vi.fn();

// Mock 모듈
vi.mock("@/lib/utils", () => ({
  cn: vi.fn((...classes) => classes.join(" ")),
}));

// Timer mock
vi.useFakeTimers();
vi.advanceTimersByTime(1000);
vi.useRealTimers();
```

## Playwright Browser Tests

**Playwright**로 실제 브라우저 환경에서 테스트합니다.

### Running Tests

```bash
# Storybook 테스트 실행
npm run test:storybook

# Storybook Test Runner
npm run storybook:test
```

### Test Configuration

Storybook Test Runner는 모든 Play function을 자동으로 실행합니다.

```typescript
// .storybook/test-runner.ts
import type { TestRunnerConfig } from "@storybook/test-runner";

const config: TestRunnerConfig = {
  async postVisit(page, context) {
    // 추가 검증 로직
    const element = page.locator("#root");
    await expect(element).toBeVisible();
  },
};

export default config;
```

## Accessibility Testing

**A11y addon**으로 접근성을 자동 검증합니다.

### Configuration

```typescript
// .storybook/preview.ts
export const parameters = {
  a11y: {
    config: {
      rules: [
        {
          id: "color-contrast",
          enabled: true,
        },
      ],
    },
    options: {
      checks: { "color-contrast": { options: { noScroll: true } } },
      restoreScroll: true,
    },
    manual: false,
  },
};
```

### Testing WCAG 2.1 AA Compliance

모든 컴포넌트는 다음을 준수해야 합니다:

- ✅ **Color Contrast**: 최소 4.5:1 비율
- ✅ **Keyboard Navigation**: Tab, Enter, Escape, Arrow keys
- ✅ **Screen Reader**: ARIA labels, roles, states
- ✅ **Focus Management**: 논리적 포커스 순서
- ✅ **Semantic HTML**: `<button>`, `<input>`, `<label>` 등

### Keyboard Navigation Testing

```typescript
export const ShouldNavigateWithKeyboard: Story = {
  tags: ["!dev", "!autodocs"],
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // 🎯 목적: 키보드로 모든 인터랙티브 요소에 접근 가능한지 확인

    // Tab으로 첫 번째 요소에 포커스
    await userEvent.tab();
    const firstButton = canvas.getAllByRole("button")[0];
    await expect(firstButton).toHaveFocus();

    // Tab으로 다음 요소로 이동
    await userEvent.tab();
    const secondButton = canvas.getAllByRole("button")[1];
    await expect(secondButton).toHaveFocus();

    // Enter로 버튼 활성화
    await userEvent.keyboard("{Enter}");

    // Escape로 닫기
    await userEvent.keyboard("{Escape}");
  },
};
```

## Best Practices

### 1. Test Isolation

각 테스트는 독립적이어야 합니다:

```typescript
// ✅ Good: 독립적인 테스트
export const ShouldOpenDialog: Story = {
  render: () => {
    const [open, setOpen] = React.useState(false);
    return <Dialog open={open} onOpenChange={setOpen} />;
  },
  play: async ({ canvasElement }) => {
    // 테스트 로직
  },
};

// ❌ Bad: 외부 상태 의존
let globalState = false;
export const ShouldOpenDialog: Story = {
  play: async () => {
    globalState = true; // 다른 테스트에 영향
  },
};
```

### 2. Clear Assertions

명확한 assertion을 사용하세요:

```typescript
// ✅ Good: 명확한 assertion
await expect(button).toHaveTextContent("Submit");
await expect(input).toHaveValue("test@example.com");
await expect(dialog).toBeVisible();

// ❌ Bad: 불명확한 assertion
await expect(button.textContent).toBe("Submit"); // DOM API 직접 사용
```

### 3. WaitFor for Async

비동기 동작은 `waitFor`를 사용하세요:

```typescript
// ✅ Good: waitFor 사용
await waitFor(() => {
  expect(canvas.getByText(/success/i)).toBeInTheDocument();
});

// ❌ Bad: 고정된 timeout
await new Promise((resolve) => setTimeout(resolve, 1000));
```

### 4. User-Centric Queries

사용자 관점의 쿼리를 사용하세요:

```typescript
// ✅ Good: 역할 기반 쿼리
canvas.getByRole("button", { name: /submit/i });
canvas.getByRole("textbox", { name: /email/i });
canvas.getByLabelText(/password/i);

// ❌ Bad: 구현 세부사항 쿼리
canvas.getByClassName("btn-primary");
canvas.querySelector("#submit-button");
```

## Common Issues

### Issue 1: Element Not Found

```typescript
// ❌ 문제: 요소를 찾을 수 없음
const button = canvas.getByRole("button");

// ✅ 해결: 대기 후 찾기
await waitFor(async () => {
  const button = await canvas.findByRole("button");
  await expect(button).toBeInTheDocument();
});
```

### Issue 2: Timeout Errors

```typescript
// ❌ 문제: 기본 timeout 초과
await waitFor(() => {
  expect(element).toBeInTheDocument();
});

// ✅ 해결: timeout 증가
await waitFor(
  () => {
    expect(element).toBeInTheDocument();
  },
  { timeout: 5000 }
);
```

### Issue 3: Multiple Elements

```typescript
// ❌ 문제: 여러 버튼이 있을 때
const button = canvas.getByRole("button");

// ✅ 해결: 구체적인 name 사용
const submitButton = canvas.getByRole("button", { name: /submit/i });
const cancelButton = canvas.getByRole("button", { name: /cancel/i });
```

## Resources

- [Storybook Play Functions](https://storybook.js.org/docs/writing-tests/interaction-testing)
- [Testing Library Queries](https://testing-library.com/docs/queries/about)
- [Vitest Documentation](https://vitest.dev)
- [Playwright Documentation](https://playwright.dev)
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
